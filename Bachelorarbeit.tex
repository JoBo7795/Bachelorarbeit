\documentclass[a4paper,12pt]{scrartcl}
 
\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{svg}
\usetikzlibrary{automata,positioning}
\usepackage{pdfpages}

\bibliographystyle{unsrt}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=blue,
    urlcolor=black
}



\title{}


\author{Johannes Bohlig}

\date{\today}


\begin{document}

\tableofcontents

\pagebreak

\section{Einleitung}

Als Anbieter von Cloud-Services hat die Firma Appointrix den Anspruch, möglichst geringe und kurze Ausfallzeiten mit ihren Services zu erreichen. Um eine maximal lange, störungsfreie Servicelaufzeit zu erreichen, ist es notwendig jederzeit den Servicestatus einsehen und mögliches Fehlverhalten frühzeitig erkennen zu können. 
Da für eine dauerhafte Kontrolle eines Services ein oder sogar mehrere Mitarbeiter benötigt werden, welche eine eintönige Kontrollaufgabe übernehmen müssten, ist es sinnvoll möglichst viele Teile der Kontrolle zu automatisieren. Diese Automatisierung bringt einerseits den Vorteil der Kosteneinsparung, da keine Mitarbeiter für diese Aufgabe benötigt werden und andererseits einen Geschwindigkeitsvorteil durch die wesentlich geringere Reaktionszeit, die durch die Geschwindigkeit von Computern gegenüber dem Menschen einhergeht.\\
Hierbei sollen vor allem Engpässe bei Ressourcen ausfindig gemacht werden, sowie Anomalien, also Fehlverhalten, in einzelnen Komponenten der Infrastruktur gefunden und behoben werden, bestenfalls noch bevor sich größere Auswirkungen auf die restlichen Komponenten ergeben.\\
Um eine automatisierte Erkennung zu ermöglichen, werden Daten sog. Metriken benötigt, die eine Entscheidung über das vorliegende Verhalten treffen lassen. Metriken müssen erhoben und ausgewertet werden, um eine Aktion aus ihnen schließen zu können, welche die vorliegende Anomalie oder den vorliegenden Engpass beheben kann.\\
Die erhobenen Metriken müssen einerseits für Menschen lesbar sein, um aktuelle Zustände widerspiegeln und entsprechend darauf reagieren zu können, andererseits ebenso für Computer auswertbar sein, um die Automatisierung durch diese zu ermöglichen.
Kubernetes bietet die Möglichkeit, mittels des sog. Kubelet und des cAdvisor Metriken zu erheben, welche den Zustand des Clusters darstellen. \\
Neben automatisierten Aktionen auf das Cluster, ist es auch sinnvoll entsprechende Stakeholder über das Fehlverhalten in Kenntnis zu setzen und diese zu benachrichtigen, um ihnen die Möglichkeit zu geben dem Verhalten auf den Grund zu gehen.\\
Diese Arbeit setzt sich das Ziel die Durchführbarkeit der automatisierten Anomalie- und Engpasserkennung nachzuweisen und die erste Implementierung innerhalb eines schon bestehenden Kubernetes-Clusters. 
Im Rahmen dieser Arbeit werden die passenden Komponenten gewählt, die zur Umsetzung der Anforderungen benötigt werden, die Infrastruktur geplant, erstellt und die korrekte Funktion evaluiert.\\
Des Weiteren wird die Relevanz verschiedener erhobener Metriken in Bezug auf ihre Verwendbarkeit beim automatisierten Detektieren von Anomalien und Engpässen dargestellt und geklärt.\\
Es werden die weit verbreiteten Tools Prometheus und Grafana verwendet und durch Eigenentwicklungen ergänzt und so eine Infrastruktur geschaffen, welche die Anforderungen erfüllen kann.

\pagebreak

\subsection{Struktur}

Die nachfolgende Arbeit ist wie folgt strukturiert:\\

\begin{description}

\item [Kapitel 2] befasst sich mit den Grundlagen die für das weitere Verständnis der Arbeit erforderlich sind.
\item [Kapitel 3] stellt den aktuellen Stand der Technik dar.
\item [Kapitel 4] erläutert Tools und Vorgehensweise bei der Datenakquise
\item [Kapitel 5] erläutert das Vorgen beim Auswerten der Metriken
\item [Kapitel 6] befasst sich mit den Automatisierten Aktionen, die aus den ausgewerteten Metriken geschlossen werden können
\item [Kapitel 7] zeigt, wie aufgestellte Regeln und Komponenten evaluiert werden
\item [Kapitel 8] diskutiert die Ergebnisse dieser Arbeit
\item [Kapitel 9] enthält das Fazit, sowie einen Ausblick in die Zukunft des Projekts

\end{description}

\section{Grundlagen}
\subsection{Kubernetes}

Kubernetes, kurz "k8s", ist eine Open-Source Software und API zur Orchestrierung und Deployment von containerisierten Anwendungen. Seit seiner Einführung 2014 hat Kubernetes ein starkes Wachstum erlebt und ist zum Quasistandard bei der Entwicklung von Cloud-Native Applikationen geworden.\\

In einer Umfrage fand die Cloud-Native Computing Foundation (CNCF) heraus, dass über 58 Prozent der Befragten Kubernetes verwendet und 40 Prozent der befragten Firmen, was über 5000 ergab, Kubernetes in der Produktion benutzen.[Umfrage CNCF ergänzen]\\


Kubernetes ist eine mittlerweile bewährte Infrastruktur und bietet Software die nötig ist um zuverlässige und skalierbare verteile Systeme zu entwickeln. \cite{Burns.2019}\\
Der Zweck eines Kubernetes-Clusters besteht darin viele, einzelne Computer als eine einzige Einheit zusammenarbeiten zu lassen.
Ein Cluster besteht aus zwei verschiedenen Arten von Komponenten, die zusammenarbeiten:
dem Node und dem Master.
Der Master stellt den Verwalter im Cluster dar. Er koordiniert alle Vorgänge, trifft also Entscheidungen die von globaler Bedeutung für das gesamte Cluster sind. Beispielsweise startet er Komponenten oder schaltet sie ab, ist aber auch für Tasks wie die Zeitplanung zuständig. Er wird über die Kubernetes-API angesprochen und steht in direkter Verbindung mit den Nodes.\cite{.20200530T15:19:3404:00} \cite{.20200316T05:14:35+01:00}
Nodes wiederum stellen die Arbeiter dar, weshalb sie auch "worker" genannt werden. Deren Aufgaben bestehen darin Pods[siehe Relevante Komponenten] aufrecht zu erhalten und die Laufzeitumgebung bereitzustellen. Nodes halten auch die Container-Runtime bereit, welche dafür zuständig ist Containerisierte Anwendungen auszuführen und so das verteilen einer Anwendung auf beliebige Hardware möglich macht.

\begin{figure}[htbp]
  \centering
  \input{KubernetesBasic.pdf_tex}
  \caption{einfache Darstellung eines Kubernetes-Cluster}
\end{figure}

\subsubsection{Relevante Komponenten}

Kubernetes bietet eine Vielzahl von Komponenten für unterschiedliche Aufgaben. Die für dieses Projekt Relevanten werden hier erklärt:

\begin{description}

\item [kubectl]:\\
kubectl ist eine Kontrollanwendung für Kubernetes. Es ist eine direkte Schnittstelle zwischen User und dem Kubernetes API-Server und kann mittels Konsolenbefehlen bedient werden.
\item [kubelet]: \\
Der kubelet ist der primäre 'node-agent'. Er ist dafür zuständig die Nodes beim Kubernetes API-Server zu registrieren. Des Weiteren verwaltet er Pods anhand einer Podspezifikation(PodSpec) und sorgt dafür, dass die Pods im Rahmen der Spezifikation "gesund" laufen.\\
Über den kubelet können diverse Metriken gesammelt werden, die über den Status des Nodes oder der darin laufenden Pods und Container Auskunft geben.
\item [Pod]:\\
Ein Pod ist eine 'execution unit' und repräsentiert einen Prozess, der in einem Cluster läuft. Ein Pod kapselt einen oder mehrere Anwendungs-Container, ein eigener Speicherbereich, eine eigene IP-Adresse sowie dessen Konfigurationsoptionen.
Die meistverwendete Container-Runtime ist,wie auch in diesem Projekt, Docker, es gibt aber auch Unterstützung für Weitere wie beispielsweise Rocket.
\item [Service]:\\
Nach der offiziellen Kubernetes-Dokumentation sind Services Eine "abstrakte Möglichkeit, eine Anwendung, die auf einer Reihe von Pods läuft, als Netzwerkdienst bereitzustellen".
Kubernetes Pods können dynamisch in ihrer Anzahl skalieren und so auch ihre IP-Adresse wechseln. Daher ist es sinnvoll die Pods über einen Service anzusprechen, der mit einem DNS ähnlichen System funktioniert und so ein Deployment über einen lesbaren Namen ansprechbar macht.  
\item [cAdvisor]:\\
Da Container von sich aus keine Informationen zu ihrem Ressourcenstatus nach außen preisgeben oder exportieren, bedarf es eines Hilfsmittels, das genau dies macht.
cAdvisor(Container Advisor) ist ein Daemon, der Ressourcen-Informationen aus Containern sammelt, verarbeitet und exportiert.\cite{.20200704T23:29:24.000Z}


\end{description}

%\subsection{Cloud-Native} 
\subsection{Go}
\subsection{Metriken}
\subsection{Prometheus}
\subsubsection{Scraping}
\subsubsection{Abfragen}
\subsubsection{Alerting}

\section{Stand der Technik}

\section{Datenaggregation}
\subsection{Toolauswahl}
\subsubsection{Metriken}
\subsubsection{Visualisierung}
\subsection{Datenquellen}
\subsection{'USE'-Methode}

\section{Auswerten der Metriken}
\subsection{Klassifizierung}
\subsection{Logische Auswertung}
\subsection{Graphische Aufbereitung}

\section{Automatisierte Aktionen}
\subsection{Aktionen}
\subsubsection{Skalieren}
\subsubsection{Anomalie-Detection}
\subsection{Komponenten und Architektur}
\subsubsection{Prometheus}
\subsubsection{Alertmanager}
\subsubsection{Alert-Action-Manager}
\subsection{Regeln}
\subsubsection{Metriken}
\subsubsection{Grenzwerte}

\section{Evaluation}
\subsection{Messaufbau}
\subsection{Regeln}
\subsection{Grenzwerte}
\subsection{Komponenten und Architektur}

\section{Diskussion}
\section{Fazit und Ausblick}

\newpage
\bibliography{Literatur}

\end{document}